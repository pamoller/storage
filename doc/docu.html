<!DOCTYPE html><html lang=""><head><meta charset="UTF-8"/><link rel="stylesheet" href="css/styles.css"/><script src="js/script.js"></script><link rel="stylesheet" href="css/prettify.css"/><script src="js/prettify.js"></script><script src="js/lang-html.js"></script><!--[if lt IE 9]><script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script><![endif]--><title>Storage</title></head><body id="id35797372"><div id="page"><header id="heading"><hgroup><h1>Storage</h1><h2>use storages in webbrowsers easily</h2></hgroup></header><p id="id35797123">With <a title="" href="http://pamoller.com/Storage.html">Storage</a> there is no need to implement different types of data storages in webbrowsers. Storage is an Open Source Javascript Library who provides a unified and asynchronus API to store Javascript objects in one of the underlying data storages: <a title="" href="http://www.w3.org/TR/IndexedDB/">IndexedDB</a>, <a title="" href="http://www.w3.org/TR/webdatabase/">WebSQL</a> or <a title="" href="http://www.w3.org/TR/webstorage/">localStorage</a>. The objects are stored in data stores and referenced by a unique key simliar to the IndexedDB API.</p><p id="id35801068">Storage is still beta. Tested Platforms: Firefox 13+, Chrome 20+, MSIE 9, Opera 12, Safari 5. To build and invoke Storage see section <a title="" href="#build">Build Storage</a>.</p><pre class="prettyprint"><code class="lang-javascript">try { 
 var stg = Storage.autoConnect(); // constructor
 var crq = stg.init({db: 'storages', version:2, stores:['datas']}); // initialization
 crq.onsuccess = function() {
   var req = stg.put({key: 'XQ121', datas:[5,7,8,9]}, 'XQ121', 'datas'); // asynchronous operation
   req.onsuccess = function(obj) {console.log('inserted successfully');}
   req.onerror = function(code, msg) {throw new Error(code);}
 }
} catch(e) {
  alert('no storage available');
}</code></pre><section id="id35801085"><h2>Introduction</h2>
<p id="id35802871">Currently there are three different types of permanent data storages in webbrowsers. localStorage is found on most webbrowsers, but it is not a database like IndexedDB or WebSQL.
So localStorage is the most unadvanced choice. The most advanced choice is IndexedDB. But implementations are not found on all browsers. Safari and Opera don't support IndexedDB. They serve WebSQL.
But the WebSQL standard is dropped from development for years. IndexedDB is it's replacement. It is an API for databases of records holding simple values and hierachical objects. Storage serves a unified API for storeing Javascript objects refrenced by keys similar to IndexedDB API, even if no IndexedDB implementation is found. In this cases WebSQL or LocalStorage are used as underlying data storage. The storages are accessed technically by StorageObjects. There are three types: Storage.IndexedDB, Storage.WebSQL and Storage.LocalStorage. </p>
</section><section id="storage-interface"><h2>Storage interface</h2>
<p id="id35802925">The top level object Storage provides an interface for createing StorageObjects. To choose the best accessible storage of the browser use Storage.autoConnect:</p>
<div class="funcsynopsis"><code><code>StorageObject</code> <strong>Storage.autoConnect</strong> (
    <code>String</code>
    db
  , 
    <code>String</code>
    store
  )</code><p><strong>Exceptions</strong>: NOSTORAGE</p></div><p id="id35802962">The first parameter is the name of the database, who is connected. The second parameter is a handy default for the store-parameter. If set, store parameter of many method calls can be obmitted. Both parameters are optional. Storage.autoConnect returns the first <code>StorageObject</code> that can be created successfully in order from: Storage.IndexedDB, Storage.WebSQL or Storage.LocalStorage. If no StorageObject can be created the NOSTORAGE exception is thrown.</p>
<pre class="prettyprint"><code class="lang-javascript">try {
  var stg = Storage.autoConnect();
} catch(e) {
  alert("no storage available");
}</code></pre>
<p id="id35802989">To create a StorageObject of either IndexedDB, WebSQL or LocalStorage use:</p>
<div class="funcsynopsis"><code><code>Storage.IndexedDB</code> <strong>Storage.connectIndexedDB</strong> (
    <code>String</code>
    db
  , 
    <code>String</code>
    store
  )</code><p><strong>Exceptions</strong>: NOTASTORAGE</p></div>
<div class="funcsynopsis"><code><code>Storage.WebSQL</code> <strong>Storage.connectWebSQL</strong> (
    <code>String</code>
    db
  , 
    <code>String</code>
    store
  )</code><p><strong>Exceptions</strong>: NOTASTORAGE</p></div>
<div class="funcsynopsis"><code><code>Storage.LocalStorage</code> <strong>Storage.connectLocalStorage</strong> (
    <code>String</code>
    db
  , 
    <code>String</code>
    store
  )</code><p><strong>Exceptions</strong>: NOTASTORAGE</p></div>
<p id="id35803096">The parameter list and their handling is the same as for the autoConnect-method. The methods return a StorageObject of the requested type, or the NOTASTORAGE exception is thrown.</p>
<pre class="prettyprint"><code class="lang-javascript">try {
  var localStg = Storage.connectLocalStorage(); // use defaults
  var sqlStg = Storage.connectWebSQL('websql');
  var idxStg = Storage.connectIndexedDB('idx', 'defaultStore');
} catch(e) {
  alert("some storage is not available");
}</code></pre>

</section><section id="id35803119"><h2>Storage.Request interface</h2>
<p id="id35803124">Most methods of StorageObject return a object of type Storage.Request. This object, can be used to define the success, error and complete callbacks of the request.</p>
<div class="funcsynopsis"><code><code>function</code> <strong>onsuccess</strong> ::= null</code></div>
<div class="funcsynopsis"><code><code>function</code> <strong>onerror</strong> ::= null</code></div>
<div class="funcsynopsis"><code><code>function</code> <strong>oncomplete</strong> ::= null</code></div>
<p id="id35803172">The success callback recives the result of the request as first parameter. The error callback recives the error code and a textual error message as input parameters. The complete callback recives no input parameters and is called last.</p>
<pre class="prettyprint"><code class="lang-javascript">try {
  var obj =  {key:'X17', values:[2,6,3]};
  var stg = Storage.autoConnect();
  var req = stg.put(obj, obj.key, 'datas');
  req.onsuccess = function(res) {}
  req.onerror = function(code, msg) {}
  req.oncomplete = function() {}
} catch(e) {
  alert("no storage available");
}</code></pre>
  <p id="id35803194">The request object servers has several instance variables:</p>
<div class="funcsynopsis"><code><code>int</code> <strong>onsuccessCounter</strong> ::= 0</code></div>
 <p id="id35803212">onsuccessCounter counts the number of invocations of the success callback.</p>
 <div class="funcsynopsis"><code><code>Number</code> <strong>errorCode</strong> ::= undefined</code></div>
<p id="id35803232">errorCode is the error code of the last error.</p>
<div class="funcsynopsis"><code><code>String</code> <strong>errorMessage</strong> ::= undefined</code></div>
<p id="id35803253">errorMessage is a human readable error message of the last error.</p>
<div class="funcsynopsis"><code><code>Array</code> <strong>stack</strong> ::= []</code></div>
 <p id="id35803273">stack is a helper array to store <a title="" href="#mapreduce">filtered results</a> from onscussess handler. It allows to implement map-reduce.</p>
 <div class="funcsynopsis"><code><code>Boolean</code> <strong>stackClosed</strong> ::= false</code></div>
<p id="id35803300">stackClosed is also helper variable for marking stack as closed.</p>
 <div class="funcsynopsis"><code><code>Array</code> <strong>timerids</strong> ::= []</code></div>
<p id="id35803320">timerids is the array of all timerids started by the request. The first timerid is the timerid of the request itself.</p>
</section><section id="id35803328"><h2>StorageObject interface</h2>
<p id="id35803333">All types of StorageObjects (Storage.IndexedDB, Storage.WebSQL or Storage.LocalStorage) serve the same interface. The StorageObject has at least two instance variables:</p>
<div class="funcsynopsis"><code><code>String</code> <strong>db</strong> ::= storage</code></div>
<p id="id35803353">The name of the connected database. It can be set by the <a title="" href="#storage-interface">Storage interface</a> and be overwritten by the configuration object of the init method, see below. By default the database storage is connected.</p>
<div class="funcsynopsis"><code><code>String</code> <strong>store</strong> ::= null</code></div>
<p id="id35803379">store is a handy default for the store-parameter. If, set it can be obmitted in the call of the following methods.</p>
<p id="id35803386">A data storage has to be initialized first by init:</p>
<div class="funcsynopsis"><code><code>Storage.Request</code> <strong>init</strong> (
    <code>Object</code>
    {db:String, version:Number, stores:Array, deleteStores:Array}
  )</code></div>
<p id="id35803416">The configuration object includes all information to set up a database and the data stores. If version is not a valid number greater than 1 the error callback with error code 2 is fired. stores references an array of stores to be created, deleteStores an array of stores to be deleted.</p>
<p id="id35803424">If you want to initialize or upgrade the database, the version number must be <em>higher</em> than the <em>actual version</em> number. <em>Use at least 2 as minimum version, cause 1 is the version of the vacuum database</em>. If version is not higher, init terminates successfully. When initializing or upgradeing the stores referenced by stores are created (if not existing) and the stores referenced by deleteStores are deleted. Deletion takes place before creation. So you can reinitialize stores with init.</p>
 <pre class="prettyprint"><code class="lang-javascript">try {
  var stg = Storage.autoConnect();
  var req = stg.init({version:2, stores:['bluedor'], deleteStores:['bluedor']});
  req.onsuccess = function() { }; // import defaults
} catch(e) {
  alert("no storage available");
}</code></pre>
<p id="id35803457"><em>Note:</em> Changes of the database configuration need exclusive rights. So it can be done only secure, if all opened database connections are closed before. If there remains open database connections, the change operation waits until they will be finished also. So - best call init only as first database operation. Otherwise your applicatin may hang. It is not a problem of Storage, it is given by the design of the underlying storages.</p>
<pre class="prettyprint"><code class="lang-javascript">try {
  var stg = Storage.autoConnect();
  stg.init({version:1, stores:[bluedor]}); // nothing to do
  stg.init({version:2, stores:[bluedor]}); // initilization only
  stg.init({version:3, stores:[bluedor]}); // blocks, if version is 1
} catch(e) {
  alert("no storage available");
}</code></pre>
<p id="id35803480">To populate the storage with records or update existing use put:</p>
<div class="funcsynopsis"><code><code>Storage.Request</code> <strong>put</strong> (
    <code>Object</code>
    obj
  , 
    <code>key</code>
    key
  , 
    <code>String</code>
    store
  )</code></div>
<p id="id35803527">The first parameter is the object to be stored. The second is the key. If key is not valid the error callback with error code 6 is fired. The third parameter is the name of the data store. store is optional, as long the default instance variable store is not null. If store is not the name of an existing data store, the error callback with error code 5 is fired. The onsuccess callback is called with obj as result. To read obejcts from the storage use get:</p>
<div class="funcsynopsis"><code><code>Storage.Request</code> <strong>get</strong> (
    <code>key</code>
    key
  , 
    <code>String</code>
    store
  )</code></div>
<p id="id35803568">The first parameter has to be a valid key, the second the name of an existing data store. The error handlig is same as for put. The onsuccess callback is called with the requested object. If no object can be found by key, the error callback is called with eroorcode 4.</p>
<pre class="prettyprint"><code class="lang-javascript">try {
  var stg = Storage.autoConnect();
  var req = stg.get("unsure", "probably");
  req.onsuccess = function(res) {
    show_result(res);
  };
  req.onerror = function (code, msg) {
    switch(code) {
      case 4:
        alert("key not found in data store");
      break;
      case 5:
        alert("data store not present");
      break;
      case 6:
        alert("key is invalid");
      break;
    }
  }
} catch(e) {
  alert("no store available");
}</code></pre>
<p id="id35803591">To read all objects from a data store or to do a map-reduce over this set use list:</p>
<div class="funcsynopsis"><code><code>Storage.Request</code> <strong>list</strong> (
    <code>String</code>
    store
  )</code></div>
  <p id="id35803616">list accepts only one parameter: If store is the name of an existing data store, even the instance variable of StorageObject set before, the error callback is fired with error code 5. The onsuccess callback is called for each record in the data store. If the data store is empty the error callback is fired with error code 3.</p>
  <p id="id35803629">The onsuccess handler can be used to filter the objects by a map-reduce. Therefore all selected objects are put to the request's stack. The completed stack is accessiable by the oncomplete handler, as shown in the following example of a pageing.</p>
<figure id="mapreduce"><pre class="prettyprint"><code class="lang-javascript">try {
 var stg = Storage.autoConnect();
 for(var i = 0; i &lt; 100; i++) {
   var obj = {key: i, vaule: i};
   stg.put(obj, obj.key, 'datas'); // populate
 }
 var req = stg.list('datas'); // map
 req.onsuccess = function(res) { // reduce
   if  (10 &lt;= res.key &lt; 20) { // filter second page
     req.stack.push(res);
   }
 };
 req.oncomplete = function(res) {
  show_results(req.stack); // show second page
  };
} catch(e) {
  alert("no storage available");
}</code></pre></figure>
<p id="id35803655">To delete a object from a data store use delete:</p>
<div class="funcsynopsis"><code><code>Storage.Request</code> <strong>delete</strong> (
    <code>String</code>
    key, 
  <code>String</code>
  store    
    )</code></div>
  <p id="id35803689">Delete takes a valid key as first function parameter and removes the key and the associated object from the data store. If the key does not exists in the data store the error callback with error code 4 will be fired.</p>
<p id="id35803696">To empty a data store use clear:</p>
 <div class="funcsynopsis"><code><code>Storage.Request</code> <strong>clear</strong> (
    <code>String</code>
    store
  )</code></div>
<p id="id35803720">The parameter list and their handling is the same as for list. The onsuccess callback is called with an empty result.</p>
</section><section id="build"><h2>Build Storage</h2>
<p id="id35803734">To build Storage from sources, checkout first https://github.com/pamoller/storage.git. Change to
the directory storage and run make. It creates a folder named release. To use Storage along HTML do like:</p>
<pre class="prettyprint"><code class="lang-html">&lt;html&gt;
 &lt;head&gt;
  &lt;script src="js/storage.js"&gt;&lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</code></pre></section><section id="errors"><h2>Error Codes</h2>
<dl>
<dt>2</dt><dd>version is not a number</dd>
<dt>3</dt><dd>no datas in data store</dd>
<dt>4</dt><dd>key not found in data store</dd>
<dt>5</dt><dd>data store not present</dd>
<dt>6</dt><dd>key is invalid</dd>
<dt>8</dt><dd>internal storage error</dd>
</dl>
</section></div></body></html>
